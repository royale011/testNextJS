import { Document, Model, model, models, Schema } from "mongoose";
import { connectToMongoDb } from "@/app/lib/mongodb/client";
import { v4 as uuidv4 } from "uuid";

export interface IBookInfo {
  // book name
  bookname: string;
}

export interface IBookExtendedInfo extends IBookInfo {
  // book description
  description?: string;
  // price
  price: number;
  // author
  author?: string;
  // genre
  genre?: string;
  // published date
  published_date?: Date;
  // publisher
  publisher?: string;
  // language
  language?: string;
}

export interface IBookWithStock extends IBookInfo {
  // stock count
  stock_count: number;
}

export interface IBookWithDeletedMark extends IBookInfo {
  // mark the book as deleted
  deleted?: boolean;
}

export interface IBook
  extends IBookWithStock,
    IBookExtendedInfo,
    IBookWithDeletedMark,
    Document {
  // unique book id
  book_id: string;
}

const BookSchema = new Schema<IBook>({
  book_id: { type: String, required: true, unique: true, default: uuidv4 },
  bookname: { type: String, required: true, unique: true },
  description: { type: String, required: false },
  price: { type: Number, required: true },
  author: { type: String, required: false },
  genre: { type: String, required: false },
  published_date: { type: Date, required: false },
  publisher: { type: String, required: false },
  language: { type: String, required: false },
  stock_count: {
    type: Number,
    required: true,
    min: [0, "out of stock"],
    default: 0,
  },
  deleted: { type: Boolean, required: false, default: false },
});

const connection = connectToMongoDb();
const Book =
  models.Book || connection.model<IBook>("Book", BookSchema, "books");
export default Book;

// update or insert book info, but not touching the stock count
// parameter bookInfo: the book info to be updated or inserted
// the book_id is generated by uuidv4
// the stock_count is not touched
// if the bookname is not found, a new book will be inserted
// if the bookname is found, the book info will be updated
// if the book is previously mark deleted, the book will be mark as not deleted
// the return value is the updated or inserted books
export async function upsertBookInfo(
  bookInfo: IBookExtendedInfo[],
): Promise<IBook[]> {
  const bulkOps = bookInfo.map((info) => {
    return {
      updateOne: {
        filter: {
          bookname: info.bookname,
        },
        update: {
          $set: {
            bookname: info.bookname,
            description: info.description,
            price: info.price,
            author: info.author,
            genre: info.genre,
            published_date: info.published_date,
            publisher: info.publisher,
            language: info.language,
            deleted: false,
          },
        },
        upsert: true,
      },
    };
  });
  return Book.bulkWrite(bulkOps).then(() => {
    return Book.find({
      bookname: { $in: bookInfo.map((info) => info.bookname) },
    });
  });
}

// update or insert book stock
// parameter bookStock: the book stock
// the book_id is generated by uuidv4
// if the bookname is not found, a new book will be inserted with only book name and stock count
// if the bookname is found, the stock count will be updated
// the deleted status is not touched
// the stock count here is a delta count; so it will use $inc method to update
// negative stock count will decrease the stock count in the database
// a non-integer stock count will be converted to integer
// if the stock count is less than 0, it will be set to 0
// the return value is the updated or inserted books
export async function upsertBookStock(
  bookStock: IBookWithStock[],
): Promise<IBook[]> {
  let bulkOps: any[] = bookStock.map((stock) => {
    return {
      updateOne: {
        filter: {
          bookname: stock.bookname,
        },
        update: {
          $set: {
            bookname: stock.bookname,
          },
          $inc: { stock_count: Math.floor(stock.stock_count) },
        },
        upsert: true,
      },
    };
  });

  // set stock count to 0 if the stock count is negative
  bulkOps.push({
    updateMany: {
      filter: {
        stock_count: { $lt: 0 },
      },
      update: {
        $set: {
          stock_count: 0,
        },
      },
    },
  });

  return Book.bulkWrite(bulkOps).then(() => {
    return Book.find({
      bookname: { $in: bookStock.map((stock) => stock.bookname) },
    });
  });
}

// mark the book as deleted or not
// parameter bookDeletedInfo: the book deleted info
// the book_id is generated by uuidv4
// if the bookname is not found, a new book will be inserted with only book name and deleted status
// if the bookname is found, the deleted status will be updated
// the book info and stock count is not touched
// as deleted mark is only to be controlled in frontend
// the return value is the updated or inserted books
export async function upsertBookDeleted(
  bookDeletedInfo: IBookWithDeletedMark[],
): Promise<IBook[]> {
  const bulkOps = bookDeletedInfo.map((info) => {
    return {
      updateOne: {
        filter: {
          bookname: info.bookname,
        },
        update: { $set: { deleted: info.deleted } },
        upsert: true,
      },
    };
  });
  return Book.bulkWrite(bulkOps).then(() => {
    return Book.find({
      bookname: { $in: bookDeletedInfo.map((info) => info.bookname) },
    });
  });
}
